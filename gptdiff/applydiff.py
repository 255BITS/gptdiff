"""
Module: applydiff

Contains the function to apply unified git diffs to files on disk.
"""

from pathlib import Path
import re
import hashlib
from collections import defaultdict

def apply_diff(project_dir, diff_text):
    """
    Applies a unified diff (as generated by git diff) to the files in project_dir
    using pure Python (without calling the external 'patch' command).

    Handles file modifications, new file creation, and file deletions.

    Returns:
        True if at least one file was modified (or deleted/created) as a result of the patch,
        False otherwise.
    """
    from pathlib import Path
    import re, hashlib

    def file_hash(filepath):
        h = hashlib.sha256()
        with open(filepath, "rb") as f:
            h.update(f.read())
        return h.hexdigest()

    def apply_patch_to_file(file_path, patch):
        """
        Applies a unified diff patch (for a single file) to file_path.

        Returns True if the patch was applied successfully, False otherwise.
        """
        # Read the original file lines; if the file doesn't exist, treat it as empty.
        if file_path.exists():
            original_lines = file_path.read_text(encoding="utf8").splitlines(keepends=True)
        else:
            original_lines = []
        new_lines = []
        current_index = 0

        patch_lines = patch.splitlines()
        # Regex for a hunk header, e.g., @@ -3,7 +3,6 @@
        hunk_header_re = re.compile(r"^@@(?: -(\d+)(?:,(\d+))?)?(?: \+(\d+)(?:,(\d+))?)? @@")
        i = 0
        while i < len(patch_lines):
            line = patch_lines[i]
            if line.lstrip().startswith("@@"):
                if line.strip() == "@@":
                    # Handle minimal hunk header without line numbers.
                    orig_start = 1
                else:
                    m = hunk_header_re.match(line.strip())
                    if not m:
                        print("Invalid hunk header:", line)
                        return False
                    orig_start = int(m.group(1)) if m.group(1) is not None else 1
                hunk_start_index = orig_start - 1  # diff headers are 1-indexed
                if hunk_start_index > len(original_lines):
                    print("Hunk start index beyond file length")
                    return False
                new_lines.extend(original_lines[current_index:hunk_start_index])
                current_index = hunk_start_index
                i += 1
                # Process the hunk lines until the next hunk header.
                while i < len(patch_lines) and not patch_lines[i].startswith("@@"):
                    pline = patch_lines[i]
                    if pline.startswith(" "):
                        # Context line must match exactly.
                        expected = pline[1:]
                        if current_index >= len(original_lines):
                            print("Context line expected but file ended")
                            return False
                        orig_line = original_lines[current_index].rstrip("\n")
                        if orig_line != expected:
                            print("Context line mismatch. Expected:", expected, "Got:", orig_line)
                            return False
                        new_lines.append(original_lines[current_index])
                        current_index += 1
                    elif pline.startswith("-"):
                        # Removal line: verify and skip from original.
                        expected = pline[1:]
                        if current_index >= len(original_lines):
                            print("Removal line expected but file ended")
                            return False
                        orig_line = original_lines[current_index].rstrip("\n")
                        if orig_line != expected:
                            print("Removal line mismatch. Expected:", expected, "Got:", orig_line)
                            return False
                        current_index += 1
                    elif pline.startswith("+"):
                        # Addition line: add to new_lines.
                        new_lines.append(pline[1:] + "\n")
                    else:
                        print("Unexpected line in hunk:", pline)
                        return False
                    i += 1
            else:
                # Skip non-hunk header lines.
                i += 1

        # Append any remaining lines from the original file.
        new_lines.extend(original_lines[current_index:])
        # Ensure parent directories exist before writing the file.
        file_path.parent.mkdir(parents=True, exist_ok=True)
        # Write the new content back to the file. Ensure the file ends with a newline
        # to match typical patch behavior and avoid tooling conflicts.
        content = "".join(new_lines)
        if content and not content.endswith("\n"):
            content += "\n"
        file_path.write_text(content, encoding="utf8")
        return True

    # Parse the diff into per-file patches.
    file_patches = parse_diff_per_file(diff_text)
    if not file_patches:
        print("No file patches found in diff.")
        return False

    # Record original file hashes.
    original_hashes = {}
    for file_path, _ in file_patches:
        target_file = Path(project_dir) / file_path
        if target_file.exists():
            original_hashes[file_path] = file_hash(target_file)
        else:
            original_hashes[file_path] = None

    any_change = False
    # Process each file patch.
    for file_path, patch in file_patches:
        target_file = Path(project_dir) / file_path
        if "+++ /dev/null" in patch:
            # Deletion patch: delete the file if it exists.
            if target_file.exists():
                target_file.unlink()
                if not target_file.exists():
                    any_change = True
                else:
                    print(f"Failed to delete file: {target_file}")
                    return False
        else:
            # Modification or new file creation.
            success = apply_patch_to_file(target_file, patch)
            if not success:
                print(f"Failed to apply patch to file: {target_file}")
                return False

    # Verify that at least one file was changed by comparing hashes.
    for file_path, patch in file_patches:
        target_file = Path(project_dir) / file_path
        if "+++ /dev/null" in patch:
            if not target_file.exists():
                any_change = True
            else:
                print(f"Expected deletion but file still exists: {target_file}")
                return False
        else:
            old_hash = original_hashes.get(file_path)
            if target_file.exists():
                new_hash = file_hash(target_file)
                if old_hash != new_hash:
                    any_change = True
                else:
                    print(f"No change detected in file: {target_file}")
            else:
                print(f"Expected modification or creation but file is missing: {target_file}")
                return False

    if not any_change:
        print("Patch applied but no file modifications detected.")
        return False
    return True

def parse_diff_per_file(diff_text):
    """Parse unified diff text into individual file patches.

    Splits a multi-file diff into per-file entries for processing. Handles:
    - File creations (+++ /dev/null)
    - File deletions (--- /dev/null)
    - Standard modifications

    Args:
        diff_text: Unified diff string as generated by `git diff`

    Returns:
        List of tuples (file_path, patch) where:
        - file_path: Relative path to modified file
        - patch: Full diff fragment for this file

    Note:
        Uses 'b/' prefix detection from git diffs to determine target paths
        This doesn't work all the time and needs to be revised with stronger models
    """
    def dedup_diffs(diffs):
        groups = defaultdict(list)
        for key, value in diffs:
            groups[key].append(value)
        return [[key, "\n".join(values)] for key, values in groups.items()]

    # Special case: handle LLM-style patch delimiters
    if "*** Begin Patch" in diff_text:
        lines = diff_text.splitlines()
        diffs = []
        current_lines = []
        current_file = None
        in_patch = False
        for line in lines:
            stripped = line.strip()
            if stripped == "*** Begin Patch":
                in_patch = True
                current_lines = []
                current_file = None
            elif stripped == "*** End Patch":
                if current_file is not None:
                    diffs.append((current_file, "\n".join(current_lines)))
                in_patch = False
            elif in_patch:
                if stripped.startswith("*** Update File:"):
                    current_file = stripped.split(":", 1)[1].strip()
                else:
                    current_lines.append(line)
        return dedup_diffs(diffs)

    header_re = re.compile(r'^(?:diff --git\s+)?(a/[^ ]+)\s+(b/[^ ]+)\s*$', re.MULTILINE)
    lines = diff_text.splitlines()

    # Check if any header line exists.
    if not any(header_re.match(line) for line in lines):
        # Fallback strategy: detect file headers starting with '--- a/' or '-- a/'
        diffs = []
        current_lines = []
        current_file = None
        deletion_mode = False
        header_line_re = re.compile(r'^-{2,3}\s+a/(.+)$')

        for line in lines:
            if header_line_re.match(line):
                if current_file is not None and current_lines:
                    if deletion_mode and not any(l.startswith("+++ /dev/null") for l in current_lines):
                        current_lines.append("+++ /dev/null")
                    diffs.append((current_file, "\n".join(current_lines)))
                current_lines = [line]
                deletion_mode = False
                file_from = header_line_re.match(line).group(1).strip()
                current_file = file_from
            else:
                current_lines.append(line)
                if "deleted file mode" in line:
                    deletion_mode = True
                if line.startswith("+++ "):
                    parts = line.split()
                    if len(parts) >= 2:
                        file_to = parts[1].strip()
                        if file_to != "/dev/null":
                            current_file = file_to[2:] if (file_to.startswith("a/") or file_to.startswith("b/")) else file_to
        if current_file is not None and current_lines:
            if deletion_mode and not any(l.startswith("+++ ") for l in current_lines):
                current_lines.append("+++ /dev/null")
            diffs.append((current_file, "\n".join(current_lines)))
        return dedup_diffs(diffs)
    else:
        # Use header-based strategy.
        diffs = []
        current_lines = []
        current_file = None
        deletion_mode = False
        for line in lines:
            m = header_re.match(line)
            if m:
                if current_file is not None and current_lines:
                    if deletion_mode and not any(l.startswith("+++ ") for l in current_lines):
                        current_lines.append("+++ /dev/null")
                    diffs.append((current_file, "\n".join(current_lines)))
                current_lines = [line]
                deletion_mode = False
                file_from = m.group(1)  # e.g. "a/index.html"
                file_to = m.group(2)    # e.g. "b/index.html"
                current_file = file_to[2:] if file_to.startswith("b/") else file_to
            else:
                current_lines.append(line)
                if "deleted file mode" in line:
                    deletion_mode = True
                if line.startswith("+++ "):
                    parts = line.split()
                    if len(parts) >= 2:
                        file_to = parts[1].strip()
                        if file_to != "/dev/null":
                            current_file = file_to[2:] if (file_to.startswith("a/") or file_to.startswith("b/")) else file_to
        if current_file is not None and current_lines:
            if deletion_mode and not any(l.startswith("+++ ") for l in current_lines):
                current_lines.append("+++ /dev/null")
            diffs.append((current_file, "\n".join(current_lines)))
        return dedup_diffs(diffs)


